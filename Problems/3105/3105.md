# 3105. Longest Strictly Increasing or Strictly Decreasing Subarray (Easy)
You are given an array of integers `nums`. Return the length of the longest subarray of `nums` which is either strictly increasing or strictly decreasing.

## Example 1
Input: nums = [1,4,3,3,2]

Output: 2

Explanation:

The strictly increasing subarrays of `nums` are `[1]`, `[2]`, `[3]`, `[3]`, `[4]`, and `[1,4]`.

The strictly decreasing subarrays of `nums` are `[1]`, `[2]`, `[3]`, `[3]`, `[4]`, `[3,2]`, and `[4,3]`.

Hence, we return `2`.

## Example 2
Input: nums = [3,3,3,3]

Output: 1

Explanation:

The strictly increasing subarrays of `nums` are `[3]`, `[3]`, `[3]`, and `[3]`.

The strictly decreasing subarrays of `nums` are `[3]`, `[3]`, `[3]`, and `[3]`.

Hence, we return `1`.

## Example 3
Input: nums = [3,2,1]

Output: 3

Explanation:

The strictly increasing subarrays of `nums` are `[3]`, `[2]`, and `[1]`.

The strictly decreasing subarrays of `nums` are `[3]`, `[2]`, `[1]`, `[3,2]`, `[2,1]`, and `[3,2,1]`.

Hence, we return `3`.

## Constraints
- `1 <= nums.length <= 50`
- `1 <= nums[i] <= 50`

## Problem Explanation

The goal is to find the longest continuous subarray that is either:

- strictly increasing, or

- strictly decreasing

A strictly increasing subarray means:

`nums[i] < nums[i+1] < nums[i+2] < ...`


A strictly decreasing subarray means:

`nums[i] > nums[i+1] > nums[i+2] > ...`

We check both at the same time while scanning the array in one pass.

## Key Idea

As we walk through the array, we keep track of two things:

- `inc` → length of the current strictly increasing streak

- `dec` → length of the current strictly decreasing streak

At each step:

If `nums[i] > nums[i-1]`

We found an increasing continuation:

 - increase `inc`

- reset `dec` to 1 because decreasing ended

- check if `ans` or `inc` is bigger

If `nums[i] < nums[i-1]`

We found a decreasing continuation:

- increase `dec`

- reset `inc` to 1 because increasing ended

- check if `ans` of `dec` is bigger

Else

Neither increasing nor decreasing:

- reset both `inc` and `dec` to 1

## Why this works

A monotonic subarray must be continuous, so as soon as the pattern breaks, the length resets. We only need to compare each number with the one before it, which makes the solution O(n) and very efficient.

## Example Walkthrough

For `nums = [1, 4, 3, 3, 2]`:

- 1 → 4 (increase) → inc = 2, dec = 1

- 4 → 3 (decrease) → inc = 1, dec = 2

- 3 → 3 (equal) → inc = 1, dec = 1

- 3 → 2 (decrease) → inc = 1, dec = 2

Maximum found = 2

## Final Answer

We return the maximum length found between all increasing and decreasing streaks.
