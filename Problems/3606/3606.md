# 3606. Coupon Code Validator (Easy)
You are given three arrays of length `n` that describe the properties of `n` coupons: `code`, `businessLine`, and `isActive`. The `ith` coupon has:
  - `code[i]`: a string representing the coupon identifier.
  - `businessLine[i]`: a string denoting the business category of the coupon.
  - `isActive[i]`: a boolean indicating whether the coupon is currently active.

A coupon is considered valid if all of the following conditions hold:
  1. `code[i]` is non-empty and consists only of alphanumeric characters (a-z, A-Z, 0-9) and underscores (`_`).
  2. `businessLine[i]` is one of the following four categories: `"electronics"`, `"grocery"`, `"pharmacy"`, `"restaurant"`.
  3. `isActive[i]` is true.

Return an array of the codes of all valid coupons, sorted first by their businessLine in the order: `"electronics"`, `"grocery"`, `"pharmacy"`, `"restaurant"`, and then by code in lexicographical (ascending) order within each category.

## Example 1
Input: code = ["SAVE20","","PHARMA5","SAVE@20"], businessLine = ["restaurant","grocery","pharmacy","restaurant"], isActive = [true,true,true,true]

Output: ["PHARMA5","SAVE20"]

Explanation:
 - First coupon is valid.
 - Second coupon has empty code (invalid).
 - Third coupon is valid.
 - Fourth coupon has special character `@` (invalid).

## Example 2
Input: code = ["GROCERY15","ELECTRONICS_50","DISCOUNT10"], businessLine = ["grocery","electronics","invalid"], isActive = [false,true,true]

Output: ["ELECTRONICS_50"]

Explanation:
 - First coupon is inactive (invalid).
 - Second coupon is valid.
 - Third coupon has invalid business line (invalid).

## Constraints
- `n == code.length == businessLine.length == isActive.length`
- `1 <= n <= 100`
- `0 <= code[i].length, businessLine[i].length <= 100`
- `code[i]` and `businessLine[i]` consist of printable ASCII characters.
- `isActive[i]` is either `true` or `false`.

## Problem Explanation
You are given information about `n` coupons using three parallel arrays:
 - `code[i]`: a string representing the coupon identifier
 - `businessLine[i]`: a string representing the coupon’s business category
 - `isActive[i]`: a boolean indicating whether the coupon is currently active

Each index `i` describes one coupon.

Valid Coupon Conditions
A coupon is considered valid if all of the following conditions are satisfied:
  1. Valid Code Format
    - `code[i]` must be non-empty
    - It may contain only:
      - lowercase letters (`a–z`)
      - uppercase letters (`A–Z`)
      - digits (`0–9`)
      - underscores (`_`)
  2. Valid Business Line
    - `businessLine[i]` must be one of exactly four allowed categories:
      ```
      "electronics", "grocery", "pharmacy", "restaurant"
      ```
  3. Active Coupon
    - `isActive[i]` must be `true`
Only coupons meeting all three conditions are kept.

Output Requirements
From all valid coupons:
  1. Collect their `code` values
  2. Sort them using two levels of ordering:
     - First by `businessLine`, in the fixed order:
       ```
       electronics → grocery → pharmacy → restaurant
       ```
     - Then, within the same business line, sort by `code` in lexicographical (ascending) order
  3. Return the sorted list of coupon codes

## Key Idea
The problem can be broken into three clear steps:
  1. Filter coupons based on validity rules (code format, allowed business line, active status)
  2. Group valid coupons by their business line
  3. Sort the results using a predefined category order, followed by alphabetical order of codes
This structured approach ensures only valid coupons are returned in the exact order required by the problem.

## Why This Works
This approach works because it directly mirrors the rules and ordering constraints defined in the problem.
  1. Independent Validation Per Coupon
    Each coupon’s validity depends only on its own properties (`code`, `businessLine`, and `isActive`).
    By checking these conditions independently for every index `i`, we ensure that:
      - Invalid coupons are excluded immediately
      - Only fully valid coupons are considered in later steps
  2. Exact Matching of Constraints
    - The code validation enforces the allowed character set and non-emptiness.
    - The business line check restricts coupons to the four explicitly allowed categories.
    - The active flag ensures only currently usable coupons are included.
    Since these checks correspond one-to-one with the problem statement, no invalid coupon can pass through.
  3. Deterministic Ordering Strategy
    The required output order is not arbitrary, it is fixed:
      - Business lines follow a predefined priority order.
      - Codes within the same business line are sorted lexicographically.
    By grouping coupons by business line (or by assigning each business line a priority index), we convert this requirement into a standard sorting problem. This      guarantees the output order is consistent and correct.
  4. Small Input Size Guarantees Efficiency
    With `n ≤ 100`, filtering and sorting operations are trivial in cost. Even a straightforward implementation runs efficiently within the constraints.

Because the algorithm strictly enforces validity rules first and applies a deterministic, rule-based sorting afterward, the final list contains only valid coupon codes and is ordered exactly as required, which ensures correctness.

## Final Answer
We return a list of valid coupon codes sorted in `electronics → grocery → pharmacy → restaurant` order, then by code in ascending lexicographical order
