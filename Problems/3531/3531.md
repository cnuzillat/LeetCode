# 3105. Longest Strictly Increasing or Strictly Decreasing Subarray (Medium)
You are given a positive integer `n`, representing an `n x n` city. You are also given a 2D grid `buildings`, where `buildings[i] = [x, y]` denotes a unique building located at 
coordinates `[x, y]`.

A building is covered if there is at least one building in all four directions: left, right, above, and below.

Return the number of covered buildings.

## Example 1
<img width="267" height="273" alt="image" src="https://github.com/user-attachments/assets/e10d3ae2-e1fa-4e83-bd5c-7939e021b64f" />

Input: n = 3, buildings = [[1,2],[2,2],[3,2],[2,1],[2,3]]

Output: 1

Explanation:
- Only building [2,2] is covered as it has at least one building:
  - above ([1,2])
  - below ([3,2])
  - left ([2,1])
  - right ([2,3])
- Thus, the count of covered buildings is 1.

## Example 2
<img width="267" height="273" alt="image" src="https://github.com/user-attachments/assets/92403da7-70bf-49b3-87e5-3085e0ce5e8e" />

Input: n = 3, buildings = [[1,1],[1,2],[2,1],[2,2]]

Output: 0

Explanation:
 - No building has at least one building in all four directions.

## Example 3
<img width="536" height="544" alt="image" src="https://github.com/user-attachments/assets/05f18b36-aa13-4e57-b4d8-dc847e6baf7b" />

Input: n = 5, buildings = [[1,3],[3,2],[3,3],[3,5],[5,3]]

Output: 1

Explanation:
 - Only building [3,3] is covered as it has at least one building:
  - above ([1,3])
  - below ([5,3])
  - left ([3,2])
  - right ([3,5])
- Thus, the count of covered buildings is 1.

## Constraints
 - `2 <= n <= 105`
 - `1 <= buildings.length <= 105 `
 - `buildings[i] = [x, y]`
 - `1 <= x, y <= n`
 - All coordinates of `buildings` are unique.

## Problem Explanation

You are given an `n x n` grid and a list of buildings, where each building is represented by its coordinates `(x, y)`.

A building at `(x, y)` is considered covered if:
 - There is at least one building to its left and to its right in the same row, and
 - There is at least one building above it and below it in the same column.

More formally, a building is covered if:
```
rowMin[y] < x < rowMax[y]
columnMin[x] < y < columnMax[x]
```
Where:
 - `rowMin[y]` is the smallest x-coordinate in row y
 - `rowMax[y]` is the largest x-coordinate in row y
 - `columnMin[x]` is the smallest y-coordinate in column x
 - `columnMax[x]` is the largest y-coordinate in column x

This guarantees the building is strictly between two other buildings horizontally and vertically.

## Key Idea

To determine whether a building is covered, we only need to know the minimum and maximum coordinates in its row and column.

So we precompute:

For each row `y`:
 - `rowMin[y]` → smallest x-coordinate
 - `rowMax[y]` → largest x-coordinate

For each column `x`:
 - `columnMin[x]` → smallest y-coordinate
 - `columnMax[x]` → largest y-coordinate

Then for every building `(x, y)`, we check if:
 - it is strictly inside its row range, and
 - strictly inside its column range.

If both are true, the building is covered.

This method avoids needing any complex geometric checks and runs in O(n + number_of_buildings) time.

## Why This Works

A building is covered only if it has:
 - another building on its left → x > `rowMin[y]`
 - another on its right → x < `rowMax[y]`
 - another above → y > `columnMin[x]`
 - another below → y < `columnMax[x]`

By computing min/max in advance for each row and column, we can verify all four conditions in constant time.
This leads to an efficient solution that scales well even when the grid is large.

## Final Answer
We return the total amount of covered buildings
